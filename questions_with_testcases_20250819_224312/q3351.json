{
  "problem_code": "problems",
  "title": "Serial Numbers",
  "tags": [],
  "text": "A manufacturer keeps an ordered table of serial numbers by listing in each row of the table a range of serial numbers along with two corresponding pieces of information called the status code and the transfer code. A four-column table stores information about ranges of serial numbers in this order: starting serial number, ending serial number, status code, transfer code. Serial numbers as well as transfer codes are integers from 1 to 231-1 (231-1 = 2147483647), and status codes are a single upper-case letter. The table is maintained in increasing order of serial numbers, serial number ranges are never allowed to overlap, and for any given serial number, the table must always accurately represent the most recent data (status code and transfer code) for that serial number.Let's say that 100,000 serial numbers are created with a status of \"A\" and a transfer code of \"1\". An entry for those serial numbers might look like this:1 100000 A 1This is obviously far more efficient than storing 100,000 individual rows all with the same status and transfer codes. The challenge arises when serial numbers within already defined ranges need to be given different status or transfer codes. For example, if serial number 12345 needs to change to status B, the above table would need to become three separate entries:1 12344 A 1\r\n12345 12345 B 1\r\n12346 100000 A 1Now let's change the transfer code of all serial numbers in the range 12000 to 12999 to 2. This gets us:1 11999 A 1\r\n12000 12344 A 2\r\n12345 12345 B 2\r\n12346 12999 A 2\r\n13000 100000 A 1Now change all existing serial numbers from 10000 to 100000 to status C and transfer code 2:1 9999 A 1\r\n10000 100000 C 2Once created a serial number will never be deleted, but it is possible to have ranges of undefined serial numbers between ranges of defined ones. To demonstrate, let's now set all serial numbers from 1000000 to 1999999 to status Z and transfer code 99:1 9999 A 1\r\n10000 100000 C 2\r\n1000000 1999999 Z 99Finally, the table is always maintained with a minimal number of rows, meaning specifically that there will never be two adjacent rows in the table where one would suffice. For example, consider the following serial number table:1 10 A 1\r\n11 20 A 1\r\n21 30 B 1The first two rows could actually be represented by a single row, meaning that the table above does not have a minimal number of rows. The same data represented by a minimal number of rows would look like this:1 20 A 1\r\n21 30 B 1The following table, however, because the first two rows have non-matching transfer codes, already contains the minimal number of rows:1 10 A 1\r\n11 20 A 2\r\n21 30 B 1Similarly, the following table cannot be reduced further because the first two rows do not represent a continuous series of serial numbers:1 10 A 1\r\n12 20 A 1\r\n21 30 B 1InputEach input case begins with a single line that is a character string naming the test case. This string contains at most 80 characters. The name \"END\" marks the end of the input. Following this will be 1 to 100 lines of the form \"A B S T\", where A, B, and T are integers in the range 1 to 231-1, S is an uppercase letter, and A<=B. These lines are, in the order they are to be applied, the serial number transactions to be recorded, where A is the start of the serial number range, B is the end of the serial number range, S is the status code, and T is the transfer code. The list of serial number transactions is terminated by a line containing only a 0 (zero) character.OutputFor each input case, echo the test case name to the output on a line by itself, followed by the resulting minimal-rows serial number table that results after all serial number transactions have been applied.ExampleInput:First Example\r\n1 100000 A 1\r\n12345 12345 B 1\r\n0\r\nAnd Another\r\n1 100000 A 1\r\n12345 12345 B 1\r\n12000 12999 A 2\r\n12345 12345 B 2\r\n0\r\nTest Case Three\r\n1 100000 A 1\r\n12345 12345 B 1\r\n12000 12999 A 2\r\n12345 12345 B 2\r\n10000 100000 C 2\r\n0\r\nExample Four\r\n1 100000 A 1\r\n12345 12345 B 1\r\n12000 12999 A 2\r\n12345 12345 B 2\r\n10000 100000 C 2\r\n1000000 1999999 Z 99\r\n0\r\nExample 5\r\n1 10 A 1\r\n21 30 B 1\r\n11 20 A 1\r\n0\r\nExample 6\r\n21 30 B 1\r\n1 10 A 1\r\n11 20 A 2\r\n0\r\nExample 7\r\n12 20 A 1\r\n21 30 B 1\r\n1 10 A 1\r\n0\r\nENDOutput:First Example\r\n1 12344 A 1\r\n12345 12345 B 1\r\n12346 100000 A 1\r\nAnd Another\r\n1 11999 A 1\r\n12000 12344 A 2\r\n12345 12345 B 2\r\n12346 12999 A 2\r\n13000 100000 A 1\r\nTest Case Three\r\n1 9999 A 1\r\n10000 100000 C 2\r\nExample Four\r\n1 9999 A 1\r\n10000 100000 C 2\r\n1000000 1999999 Z 99\r\nExample 5\r\n1 20 A 1\r\n21 30 B 1\r\nExample 6\r\n1 10 A 1\r\n11 20 A 2\r\n21 30 B 1\r\nExample 7\r\n1 10 A 1\r\n12 20 A 1\r\n21 30 B 1",
  "sample_input": "1 100000 A 1",
  "sample_output": "1 12344 A 1\r\n12345 12345 B 1\r\n12346 100000 A 1",
  "link": "https://www.spoj.com/problems/SERIALN",
  "scraped_at": "2025-08-17 00:34:10",
  "test_cases": [
    {
      "input": "1 100000 A 1",
      "expected_output": "1 12344 A 1\r\n12345 12345 B 1\r\n12346 100000 A 1",
      "type": "sample_1",
      "description": "Original sample 1 from problem statement"
    },
    {
      "input": "10 6 9\n3 9 ff 8",
      "expected_output": "To be computed",
      "type": "small_case_2",
      "description": "Generated small test case"
    },
    {
      "input": "2 3 8\n8 7 vvrk 1",
      "expected_output": "To be computed",
      "type": "small_case_3",
      "description": "Generated small test case"
    },
    {
      "input": "1 9 9\n1 6 z 9",
      "expected_output": "To be computed",
      "type": "small_case_4",
      "description": "Generated small test case"
    },
    {
      "input": "58 70 58\n53 89 ehxot 86",
      "expected_output": "To be computed",
      "type": "medium_case_5",
      "description": "Generated medium test case"
    },
    {
      "input": "14 33 29\n61 33 gkwkt 47",
      "expected_output": "To be computed",
      "type": "medium_case_6",
      "description": "Generated medium test case"
    },
    {
      "input": "1 92 76\n58 22 rhsf 76",
      "expected_output": "To be computed",
      "type": "medium_case_7",
      "description": "Generated medium test case"
    },
    {
      "input": "30 55 90\n55 95 r 53",
      "expected_output": "To be computed",
      "type": "medium_case_8",
      "description": "Generated medium test case"
    },
    {
      "input": "31 11 56\n64 81 eqe 49",
      "expected_output": "To be computed",
      "type": "medium_case_9",
      "description": "Generated medium test case"
    },
    {
      "input": "390 89 197\n85 451 ohec 461",
      "expected_output": "To be computed",
      "type": "large_case_10",
      "description": "Generated large test case"
    },
    {
      "input": "82 433 460\n460 480 ebv 60",
      "expected_output": "To be computed",
      "type": "large_case_11",
      "description": "Generated large test case"
    },
    {
      "input": "190 303 221\n217 174 axt 246",
      "expected_output": "To be computed",
      "type": "large_case_12",
      "description": "Generated large test case"
    },
    {
      "input": "462 462 117\n313 161 cr 482",
      "expected_output": "To be computed",
      "type": "large_case_13",
      "description": "Generated large test case"
    },
    {
      "input": "394 286 232\n356 224 yo 247",
      "expected_output": "To be computed",
      "type": "large_case_14",
      "description": "Generated large test case"
    },
    {
      "input": "347 296 264\n75 383 d 284",
      "expected_output": "To be computed",
      "type": "large_case_15",
      "description": "Generated large test case"
    },
    {
      "input": "106 175 405\n209 297 iyc 248",
      "expected_output": "To be computed",
      "type": "large_case_16",
      "description": "Generated large test case"
    },
    {
      "input": "1000 1000 1000\n1000 1000 inmyk 1000",
      "expected_output": "To be computed",
      "type": "max_case_17",
      "description": "Generated max test case"
    },
    {
      "input": "1000 1000 1000\n1000 1000 sfaey 1000",
      "expected_output": "To be computed",
      "type": "max_case_18",
      "description": "Generated max test case"
    },
    {
      "input": "1 2 999\n1 1 r 1000",
      "expected_output": "To be computed",
      "type": "edge_case_19",
      "description": "Generated edge test case"
    },
    {
      "input": "999 2 999\n1000 999 biid 999",
      "expected_output": "To be computed",
      "type": "edge_case_20",
      "description": "Generated edge test case"
    }
  ],
  "test_cases_generated_at": "2025-08-19 22:43:23",
  "total_test_cases": 20
}