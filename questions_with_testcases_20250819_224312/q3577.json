{
  "problem_code": "problems",
  "title": "Bank robbery",
  "tags": [],
  "text": "The city is plagued with bank robbers, and last year there was a robbery each week in some bank in the city. Police wants to fight this plague, and has to come up with a strategy to solve the problem. One obvious solution would be to place a police patrol at every bank, but this would cost too much money, and because of the crisis it is not possible to choose this solution.An alternative solution is as follows. Police is alerted about the robbery right after it happened, and can react pretty fast. Robbers use only either motors or cars. Police is able to block any crossroad in the city, and once a crossroad is blocked it is sure that the robbers will be caught if they try to pass the blockage. Moreover, it is possible to forecast some possible destinations of escape from a given bank. Thus the strategy in this case would be to, immediately after a robbery, block some crossroads to make it impossible to reach an escape destination. It would be also great if the number of blockages would be as small as possible, since then the action is cheaper, more effective, and less troublesome for the citizens.Obviously, if we would compute the smallest number of crossroads that make it impossible to pass from a given bank to given escape points, then this information would be actually useless for the police. Because of the geometry of the city, most likely the smallest set of blockages would consist of couple of crossroads right next to the bank, and by the time police would arrive there, the robbers would be already somewhere else. Thus during the chase, police wants to make real-time decisions that depend on the progress of the situation. To make smart decisions police needs an efficient computer program to compute blockages, and it is your task to write this program. Your program has to read the description of the city map and two locations s and t. It has to compute and return one number, the minimum number of blocked crossroads that will make it impossible to go from location s to location t.InputYour program reads from the standard input. In the first line of input you are given two natural numbers n and m (1 < n ≤ 1000, 1≤ m ≤ 5000), where n is the number of crossroads in the city, and m is the number of streets, where each street connects two crossroads; any two crossroads can be connected by at most one street. Crossroads are numbered from 1 to n. In the line number 2 of the input you are given two numbers s and t, indicating the crossroads that have to be disconnected. In the next m lines of the input you will be given the description of the connections; each such line consists of two numbers c1, c2 and it means that there is a two-way street connecting crossroads c1 and c2.OutputOn the standard output your program has to write one number, the smallest number of crossroads that, when blocked, make it impossible to reach t from s. You may assume that there is no street directly connecting s and t.Example 1Input:10 141 101 21 31 42 53 53 64 65 75 86 86 97 108 109 10Output:2Example 2Input:10 145 101 21 31 42 53 53 64 65 75 86 86 97 108 109 10Output:3",
  "sample_input": "Input:10 141 101 21 31 42 53 53 64 65 75 86 86 97 108 109 10Output:2",
  "sample_output": "Input:10 145 101 21 31 42 53 53 64 65 75 86 86 97 108 109 10Output:3",
  "link": "https://www.spoj.com/problems/BANKROB",
  "scraped_at": "2025-08-17 00:34:26",
  "test_cases": [
    {
      "input": "10 141 101 21 31 42 53 53 64 65 75 86 86 97 108 109 10",
      "expected_output": "2",
      "type": "sample_1",
      "description": "Original sample 1 from problem statement"
    },
    {
      "input": "10 145 101 21 31 42 53 53 64 65 75 86 86 97 108 109 10",
      "expected_output": "3",
      "type": "sample_2",
      "description": "Original sample 2 from problem statement"
    },
    {
      "input": "7 7 1 6 5 10 2 2 4 2 10 1 1 6 4 8 8",
      "expected_output": "To be computed",
      "type": "small_case_3",
      "description": "Generated small test case"
    },
    {
      "input": "6 9 6 7 5 2 2 2 10 7 4 6 6 3 2 9 2",
      "expected_output": "To be computed",
      "type": "small_case_4",
      "description": "Generated small test case"
    },
    {
      "input": "1 3 4 7 2 3 5 10 10 5 3 2 7 1 5 4 4",
      "expected_output": "To be computed",
      "type": "small_case_5",
      "description": "Generated small test case"
    },
    {
      "input": "74 20 59 39 48 10 3 3 74 89 4 4 74 17 69 27 94",
      "expected_output": "To be computed",
      "type": "medium_case_6",
      "description": "Generated medium test case"
    },
    {
      "input": "3 82 3 30 38 64 98 3 29 30 41 2 67 37 95 87 48",
      "expected_output": "To be computed",
      "type": "medium_case_7",
      "description": "Generated medium test case"
    },
    {
      "input": "70 77 64 51 30 17 31 92 43 45 53 75 49 70 55 8 62",
      "expected_output": "To be computed",
      "type": "medium_case_8",
      "description": "Generated medium test case"
    },
    {
      "input": "34 8 76 19 38 80 13 50 93 68 72 23 28 24 21 52 40",
      "expected_output": "To be computed",
      "type": "medium_case_9",
      "description": "Generated medium test case"
    },
    {
      "input": "45 25 14 37 52 6 72 26 36 77 20 72 97 62 11 50 63",
      "expected_output": "To be computed",
      "type": "medium_case_10",
      "description": "Generated medium test case"
    },
    {
      "input": "90 171 383 214 109 303 413 402 376 490 411 423 441 345 455 236 499",
      "expected_output": "To be computed",
      "type": "large_case_11",
      "description": "Generated large test case"
    },
    {
      "input": "219 156 247 89 468 446 295 128 116 449 261 67 72 261 223 442 262",
      "expected_output": "To be computed",
      "type": "large_case_12",
      "description": "Generated large test case"
    },
    {
      "input": "247 322 233 276 444 496 278 413 143 450 384 76 90 459 315 390 87",
      "expected_output": "To be computed",
      "type": "large_case_13",
      "description": "Generated large test case"
    },
    {
      "input": "205 457 66 359 89 128 338 97 426 367 355 370 95 205 227 61 290",
      "expected_output": "To be computed",
      "type": "large_case_14",
      "description": "Generated large test case"
    },
    {
      "input": "341 158 227 329 209 191 91 451 95 224 485 352 272 252 128 335 374",
      "expected_output": "To be computed",
      "type": "large_case_15",
      "description": "Generated large test case"
    },
    {
      "input": "92 231 353 179 217 297 133 343 92 101 130 442 59 232 486 139 84",
      "expected_output": "To be computed",
      "type": "large_case_16",
      "description": "Generated large test case"
    },
    {
      "input": "76 145 251 385 191 243 391 273 65 398 154 250 424 55 165 401 180",
      "expected_output": "To be computed",
      "type": "large_case_17",
      "description": "Generated large test case"
    },
    {
      "input": "1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
      "expected_output": "To be computed",
      "type": "max_case_18",
      "description": "Generated max test case"
    },
    {
      "input": "1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
      "expected_output": "To be computed",
      "type": "max_case_19",
      "description": "Generated max test case"
    },
    {
      "input": "1 1000 999 999 2 1000 1000 1000 1 2 1000 1000 2 999 999 999 1",
      "expected_output": "To be computed",
      "type": "edge_case_20",
      "description": "Generated edge test case"
    }
  ],
  "test_cases_generated_at": "2025-08-19 22:43:24",
  "total_test_cases": 20
}