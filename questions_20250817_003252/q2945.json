{
  "problem_code": "problems",
  "title": "I LOVE Kd",
  "tags": [],
  "text": "The \"I-Love-Kd-trees'' annual con is receiving too many applicants so they decided to complicate a bit the task used to select participants. (They realized some people were using other data structures to solve their problems, so they designed this problem, almost only solvable with Kd-trees).You are given a list ofNnumbers andQqueries. Each query can be of two types.Type-0queries (marked with 0 in the input), consist of three integers:i,landk; letdbe thek-thsmallest element until the indexi(i.e. if the first i +1 elements were sorted in non-descending way,dwould be the element at index k - 1). Then, the answer to each query is the index of thel-thoccurrence ofdin the array. If there's no such index, the answer is -1.Type-1queries (marked with 1 in the input) are contiguous-swap update-queries, and consists of a single integeri. When a type-1 query is executed the elements at index i and i +1 in the list must be swapped.You have to consider that all indexes are counted starting with 0.InputInput consists of one test case.The first line contains two integers,N(1 ≤ N ≤ 106) andQ(1 ≤ Q ≤ 105).The next line containsNpossible distinct integersai(-109≤ ai ≤ 109).ThenQlines follow. Each of them starts with an integer which can be 0 or 1, denoting the type of the query. If it’s 0, then three integersi,landkfollow (0 ≤ i < N, 1 ≤ k ≤ i+1, 1 ≤ l ≤ N).If it’s 1, then an integerifollows, meaning that you have to swap the elements at indexes i and i+1 (0 ≤ i ≤ N-1).OutputFor each query of type-0 (in the same order as the input) output a single line with the answer to that query.ExampleInput:10 62 3 1 1 2 7 9 1 2 60 2 3 21 11 20 2 3 21 00 0 2 1Output:872",
  "sample_input": "Input:10 62 3 1 1 2 7 9 1 2 60 2 3 21 11 20 2 3 21 00 0 2 1Output:872",
  "sample_output": "Not found",
  "link": "https://www.spoj.com/problems/ILKQUERYIII",
  "scraped_at": "2025-08-17 00:34:12"
}