{
  "problem_code": "problems",
  "title": "Swap (Medium",
  "tags": [],
  "text": "Let's play with sequence of non negative integer. Given two sequence ofnnon negative integers (a1, a2... an) and (b1, b2... bn). Both sequence has maximum element less thank, max(a1,a2... an)<kand max(b1, b2... bn)<k. The game rule is you can edit both sequence with this operation: swap aiand biwith 1≤i≤n, and the goal is to make sequenceaandbbecome increasing sequence: ai≤ajif and only ifi≤jand bi≤bjif and only ifi≤j. But not all initial sequenceaandbcan be solved.For example (2, 0) and (0, 1) is a pair of sequence that can't be solved:If you don't swap any element, you have (2, 0) and (0, 1), but sequence (2, 0) is not increasing.If you swap first element only, then the pair become like this (0, 0) and (2, 1), sequence (2, 1) is not increasing.If you swap second element only, then the pair become like this (2, 1) and (0, 0), again (2, 1) is not increasing.If you swap both element, then the pair become like this (0, 1) and (2, 0), again (2, 0) is not increasingSo it's impossible to solve if initial sequence is (2, 0) and (0, 1), because all possible move can't make both sequence become increasing.Now givennandk, your task is to compute number of different pair of initial sequence (a,b) that can be solved with game described above.InputFirst line there is an integerTdenoting number of test case, thenTtest cases follow.For each case, there are two integersnandkwriten in one line, separated by a space.OutputFor each case, output number of different pair of initial sequence (a,b), since the answer can be large, output the answer modulo 109+7.Constraints0 <T≤ 1050 < min(n,k) ≤ 2000 < max(n,k) < 1018ExampleInput:6\r\n2 1\r\n1 2\r\n1 3\r\n2 2\r\n3 2\r\n2 3Output:1\r\n4\r\n9\r\n11\r\n26\r\n46ExplanationHere is list of all possible pair of initial sequence (a,b) on each case:Case 1: {[(0, 0), (0, 0)]}Case 2: {[(0), (0)], [(0), (1)], [(1), (0)], [(1), (1)]}Case 3: {[(0), (0)], [(0), (1)], [(0), (2)], [(1), (0)], [(1), (1)], [(1), (2)], [(2), (0)], [(2), (1)], [(2), (2)]}Case 4: {[(0, 0), (0, 0)], [(0, 0), (0, 1)], [(0, 0), (1, 1)], [(0, 1), (0, 0)], [(0, 1), (0, 1)], [(0, 1), (1, 0)], [(0, 1), (1, 1)], [(1, 0), (0, 1)], [(1, 1), (0, 0)], [(1, 1), (0, 1)], [(1, 1), (1, 1)]}Case 5: {[(0, 0, 0), (0, 0, 0)], [(0, 0, 0), (0, 0, 1)], [(0, 0, 0), (0, 1, 1)], [(0, 0, 0), (1, 1, 1)], [(0, 0, 1), (0, 0, 0)], [(0, 0, 1), (0, 0, 1)], [(0, 0, 1), (0, 1, 0)], [(0, 0, 1), (0, 1, 1)], [(0, 0, 1), (1, 1, 0)], [(0, 0, 1), (1, 1, 1)], [(0, 1, 0), (0, 0, 1)], [(0, 1, 0), (1, 0, 1)], [(0, 1, 1), (0, 0, 0)], [(0, 1, 1), (0, 0, 1)], [(0, 1, 1), (0, 1, 1)], [(0, 1, 1), (1, 0, 0)], [(0, 1, 1), (1, 0, 1)], [(0, 1, 1), (1, 1, 1)], [(1, 0, 0), (0, 1, 1)], [(1, 0, 1), (0, 1, 0)], [(1, 0, 1), (0, 1, 1)], [(1, 1, 0), (0, 0, 1)], [(1, 1, 1), (0, 0, 0)], [(1, 1, 1), (0, 0, 1)], [(1, 1, 1), (0, 1, 1)], [(1, 1, 1), (1, 1, 1)]}Case 6: {[(0, 0), (0, 0)], [(0, 0), (0, 1)], [(0, 0), (0, 2)], [(0, 0), (1, 1)], [(0, 0), (1, 2)], [(0, 0), (2, 2)], [(0, 1), (0, 0)], [(0, 1), (0, 1)], [(0, 1), (0, 2)], [(0, 1), (1, 0)], [(0, 1), (1, 1)], [(0, 1), (1, 2)], [(0, 1), (2, 2)], [(0, 2), (0, 0)], [(0, 2), (0, 1)], [(0, 2), (0, 2)], [(0, 2), (1, 0)], [(0, 2), (1, 1)], [(0, 2), (1, 2)], [(0, 2), (2, 0)], [(0, 2), (2, 1)], [(0, 2), (2, 2)], [(1, 0), (0, 1)], [(1, 0), (0, 2)], [(1, 1), (0, 0)], [(1, 1), (0, 1)], [(1, 1), (0, 2)], [(1, 1), (1, 1)], [(1, 1), (1, 2)], [(1, 1), (2, 2)], [(1, 2), (0, 0)], [(1, 2), (0, 1)], [(1, 2), (0, 2)], [(1, 2), (1, 1)], [(1, 2), (1, 2)], [(1, 2), (2, 1)], [(1, 2), (2, 2)], [(2, 0), (0, 2)], [(2, 1), (0, 2)], [(2, 1), (1, 2)], [(2, 2), (0, 0)], [(2, 2), (0, 1)], [(2, 2), (0, 2)], [(2, 2), (1, 1)], [(2, 2), (1, 2)], [(2, 2), (2, 2)]}Other InfoTest case (nandk) is generated randomly using this rule:Probability thatn>korn<=kis ~50% each.Maximumnandkis random log-uniform.Minimumnandkis random uniform.Click here if you want to know my program speed and other detail.Explanation about my Algorithm complexity:My 2.8KB of python 3 code that got AC in 18.7s, the complexity is O(min(n,k)3) \"This is direct translation [line by line] of my C code, there are many room for optimisations like fast I/O, data structure, etc\"My 3.7KB of C code that got AC in 6.36s, the complexity is O(min(n,k)4)My 3.8KB of C code that got AC in 0.53s, the complexity is O(min(n,k)3) \"Note that although the size of code is similar, but my O(min(n,k)4) and O(min(n,k)3) code is very different\"To challenge fast language user with O(min(n,k)3) complexity, I made thisHard version. For slow language user this medium version will be look like hard version ;-) good luck.About complexity, I've proved using math that no algo with complexity better than O(min(n,k)2), this is the lower bound. My best algo for now is O(min(n,k)3), this is the upper bound. So the optimal algo lies between that lower and upper bound. I still don't have proof that my algo is optimal, so there is possibility that there is an algorithm that better than O(min(n,k)3).Time limit ~37× my program top speed.See also:Another problem added by Tjandra Satria Gunawan",
  "sample_input": "Input:6\r\n2 1\r\n1 2\r\n1 3\r\n2 2\r\n3 2\r\n2 3Output:1\r\n4\r\n9\r\n11\r\n26\r\n46",
  "sample_output": "Not found",
  "link": "https://www.spoj.com/problems/SWAP_MED",
  "scraped_at": "2025-08-17 00:33:51"
}