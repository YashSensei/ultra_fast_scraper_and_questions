{
  "problem_code": "problems",
  "title": "Bad XOR",
  "tags": [],
  "text": "You are given an array A of N elements. Also you are given another array B of M elements. Any subset (i­1, i2, i3... ip) is bad IFF (Ai1⊕ Ai2⊕ ... ⊕ Aip) equals any value of B. (⊕ means Bitwise XOR, which can be found with ^ syntax in popular programming languages.) Now your job is to find the number of good subsets. Empty subset has XOR value of 0.InputThe first line of input denotes the number of test cases T (1 ≤ T ≤ 20). The first line of each test case contains two integers N and M (0 ≤ N, M ≤ 1000). The next line contains N integers of the array A (0 ≤ Ai≤ 1000). The next line contains M integers of the array B (0 ≤ Bi≤ 1000). You can assume that each element of array B will be unique.OutputFor each case, print the case number and the total numbers of good subsets in a line. As the result can be very big, output it modulo 100000007.ExampleInput:2\r\n2 3\r\n1 2\r\n0 1 2\r\n1 3\r\n1\r\n0 1 2Output:Case 1: 1\r\nCase 2: 0Problem Setter: Nafis Sadique, Special Thanks: Ahmad Faiyaz",
  "sample_input": "Input:2\r\n2 3\r\n1 2\r\n0 1 2\r\n1 3\r\n1\r\n0 1 2Output:Case 1: 1\r\nCase 2: 0",
  "sample_output": "Not found",
  "link": "https://www.spoj.com/problems/BADXOR",
  "scraped_at": "2025-08-17 00:34:27"
}