{
  "problem_code": "problems",
  "title": "Random Number",
  "tags": [],
  "text": "A Black Box algorithm supposes that natural number sequenceu(1), u(2) ... u(N)is sorted\r\nin non-descending order,N ≤ Mand for eachp(1 ≤ p ≤ N) an inequalityp ≤ u(p) ≤ Mis valid.Making tests for this algorithm we have met with the following problem. For setting a random sequence{u(i)}a usual random data generator did not fit. As the sequence itself had been imposed certain\r\nrestrictions, the method of choosing the next random element (in the interval defined by restrictions) did\r\nnot give the random sequence as a whole.We have come to a conclusion that the problem can be solved in the following way. If we arrange\r\nall possible sequences in certain order (for example, in lexicographical order) and assign each\r\nsequence its number, after choice of the random number it is possible to take the correspondent\r\nsequence for the random one. At the first glance it seems enough to make up a program generating\r\nall these sequences in such order. Alas! Even having not great values ofMandNit would have\r\ntaken any powerful modern computer centuries to enumerate all such sequences. It turned out it was\r\npossible to avoid generating all sequences if we managed to create required sequence according to\r\nits number immediately. But even this statement does not cover all. As the amount of sequences is\r\nquite large, the number can be a long one, composed of hundreds decimal digits, though our\r\nrandom data generator could give only normal numbers. We decided to produce a long random\r\nnumber from a real random number distributed in [0, 1]. Namely, present the number in binary\r\nnotation:0.b(1)b(2)..., where allb(i) = 0 or 1. Let us set a\r\nregulation to associate such real number to an integer from [A,B] segment:FormulaHere we suppose, thatA ≤ B, p ≥ 0and \"div 2\" is an integer division by 2.LetM,N(1 ≤ N ≤ M ≤ 200) and a binary real number0.b(1)b(2) ... b(p)(1 ≤ p ≤ 400) be given.Write a program to find out the correspondingu(1), u(2) ... u(N)sequence, i.e. to find a sequence\r\nwithG(1, T, 0.b(1)b(2) ... b(p))number in lexicographical order of all possible{u(i)}for the givenMandN(Tis the quantity of such sequences). Numeration begins with 1.\r\nKeep in mind that in lexicographical order{l(i)}proceeds{h(i)}if after omitting equal\r\nbeginnings, the first number of{l(i)}tail is smaller than the first number or{h(i)}tail.The following example illustrates the list of all possible sequences forM= 4 andN= 3 in lexicographical order.A note (it does not concern the solution of this task):The choice of random binary vector0.b(1)b(2) ... b(p)does not give an absolute uniform random\r\ndata generator if we use the Formula. However, taking into account the fact that [A,B] interval is big\r\nwe shall obtain a distribution applicable in most cases.Example1, 2, 3\r\n1, 2, 4\r\n1, 3, 3\r\n1, 3, 4\r\n1, 4, 4\r\n2, 2, 3\r\n2, 2, 4\r\n2, 3, 3\r\n2, 3, 4\r\n2, 4, 4\r\n3, 3, 3\r\n3, 3, 4\r\n3, 4, 4\r\n4, 4, 4(hereT= 14)InputThe first line of the input is an integer K ≤ 10, followed by K datasets.The first line of each dataset containsMandN. The second line\r\ncontains binary real number0.b(1)b(2) ... b(p)(without leading, trailing and other spaces).OutputFor each dataset, write into the output data file the corresponding sequenceu(1), u(2) ... u(N).\r\nThe sequence numbers should be separated with spaces and end-of-line characters.\r\nThere should be up to 20 numbers in each line. If necessary, the numbers will have leading blanks to occupy 3 characters.ExampleInput:1\r\n4 3\r\n0.01101101011110010001101010001011010Output:2   2   4",
  "sample_input": "1, 2, 3\r\n1, 2, 4\r\n1, 3, 3\r\n1, 3, 4\r\n1, 4, 4\r\n2, 2, 3\r\n2, 2, 4\r\n2, 3, 3\r\n2, 3, 4\r\n2, 4, 4\r\n3, 3, 3\r\n3, 3, 4\r\n3, 4, 4\r\n4, 4, 4",
  "sample_output": "Input:1\r\n4 3\r\n0.01101101011110010001101010001011010Output:2   2   4",
  "link": "https://www.spoj.com/problems/RNUMBER",
  "scraped_at": "2025-08-17 00:34:22"
}