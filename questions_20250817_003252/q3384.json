{
  "problem_code": "problems",
  "title": "Huffman´s Greed",
  "tags": [],
  "text": "In the following we define the basic terminology of trees.\r\nAtreeis defined inductively: It has arootwhich is either anexternal node(a leaf), or aninternal nodehaving a sequence of trees as its children.\r\nAn internal node is also called theparentof the roots of its child trees.\r\nThelevelof a node in a tree is defined inductively: The root has level0, and the level of a node is1more than the level of its parent node.Every internal node of abinary treehas precisely two children, its left sub-tree and its right sub-tree.\r\nEvery internal node of alabelled binary treeis additionally marked with a string, its label.\r\nAbinary search treeis a labelled binary tree where every internal nodetsatisfies the following condition: All labels of nodes in the left sub-tree oftare less than the label oftwhich is, in turn, less than all labels of nodes in the right sub-tree oft.\r\nFor this condition, we assume lexicographic, i.e., alphabetic order on the strings.Aninorder traversalof a tree is defined recursively: A leaf is just visited, and for an internal node first its left sub-tree is traversed inorder, then the node itself is visited, finally its right sub-tree is traversed inorder.\r\nIt follows that an inorder traversal of a binary search tree yields the labels in lexicographic order.\r\nNote that binary search trees whose shapes differ may nevertheless yield the same sequence of strings while being traversed inorder.When a given stringsis looked for in a binary search tree, we comparesto the labellof the root.\r\nWe are done ifs=l, otherwise ifs < lwe continue to search in the left sub-tree, and ifs>lin the right sub-tree.\r\nIf a leaf is reached, we know thatsis not in the tree.The number of comparisons performed in such a search procedure depends onsand the actual shape of the search tree.\r\nTherefore, there is an interest in constructing binary search trees that store a given sequence of strings but provide as efficient access as possible.\r\nOf course, we don't know in advance which strings will be looked up in the tree, so we need to make some assumptions.Letnbe the number of strings that are to be stored in the binary search tree.\r\nLetK1,...,Knbe these strings in lexicographic order.\r\nLetp1,...,pnandq0,...,qnbe2n+1non-negative real numbers such that∑i=1..npi+ ∑i=0..nqi= 1.\r\nThe interpretation of these numbers is:pi= probability that the search argumentsisKi.qi= probability thatslies (lexicographically) strictly betweenKiandKi+1.By convention,q0is the probability thatsis less thanK1, andqnis the probability thatsis greater thanKn.\r\nWe want to find a binary search tree containing nodes with labelsK1,...,Knthat minimises the expected number of comparisons in the search, namelycost = ∑i=1..npi*(1 + level of internal node Ki) + ∑i=0..nqi*(level of leaf between Kiand Ki+1).The leaf betweenKiandKi+1is that leaf reached in the search for a stringsthat lies (lexicographically) strictly betweenKiandKi+1.\r\nAdhere to the convention stated above for the border cases.The following figure illustrates the first test case of the sample input.\r\nIt shows the two possible binary search trees, the probabilities and the associated costs.Input SpecificationThe input contains several test cases.\r\nEvery test case starts with an integern.\r\nYou may assume that1<=n<=200.\r\nThen follow2n+1non-negative integers denoting frequencies.\r\nLetsbe the sum of all frequencies.\r\nYou may assume that1<=s<=1000000.\r\nThe probabilitiesp1,...,pnandq0,...,qnare calculated in this order by dividing the frequencies bys.\r\nThe last test case is followed by a zero.Output SpecificationFor each test case devise a binary search tree whose cost is minimal for the specified probabilities.\r\nOutput the integercost*sfor such a tree.Sample Input2\r\n20 15 15 25 25\r\n35\r\n142 35 58 5 20 5 10 9 15 23 129 4 52 5 38 18 9 7 2 4 266 93 5 18 18 27 5 10 11 180 4 32 21 3 21\r\n0 55 27 36 85 31 58 3 334 0 98 27 113 89 180 0 62 12 0 37 0 3 64 70 0 277 0 0 0 170 0 18 76 27 3 29\r\n0Sample Output160\r\n13637",
  "sample_input": "2\r\n20 15 15 25 25\r\n35\r\n142 35 58 5 20 5 10 9 15 23 129 4 52 5 38 18 9 7 2 4 266 93 5 18 18 27 5 10 11 180 4 32 21 3 21\r\n0 55 27 36 85 31 58 3 334 0 98 27 113 89 180 0 62 12 0 37 0 3 64 70 0 277 0 0 0 170 0 18 76 27 3 29\r\n0",
  "sample_output": "160\r\n13637",
  "link": "https://www.spoj.com/problems/GREEDULM",
  "scraped_at": "2025-08-17 00:34:18"
}