{
  "problem_code": "problems",
  "title": "The Proper Key",
  "tags": [],
  "text": "Many people think that Tetris was invented by two Russian programmers. But that\r\nis not the whole truth. The idea of the game is very old – even the Egyptians had\r\nsomething similar. But they did not use it as a game. Instead, it was used as\r\na very complicated lock. The lock was made of wood and consisted of a large\r\nnumber of square fields, laid out in regular rows and columns. Each field was\r\neither completely filled with wood, or empty. The key for this lock was\r\ntwo-dimensional and it was made by joining square parts of the same size\r\nas the fields of the lock. So they had a 2D lock and 2D key that could be\r\ninserted into the lock from the top. The key was designed so that it was\r\nnot possible to move it upwards. It could only fall down and it could\r\nslide sideways – exactly like in a Tetris game. The only difference is\r\nthat the key could not be rotated. Rotation in Tetris is really a Russian\r\ninvention.The entry gate into the Pyramid has such a lock. The ACM archaeologists have\r\nfound several keys and one of them belongs to the lock with a very high\r\nprobability. Now they need to try them out and find which one to use. Because\r\nit is too time-consuming to try all of them, it is better to begin with those keys that\r\nmay be inserted deeper into the lock. Your program should be able to\r\ndetermine how deep a given key can be inserted into a given lock.InputThe input consists ofTtest cases. The number of them (T) is given on\r\nthe first line of the input file.\r\nEach test case begins with a line containing two integersRandC(1 ≤ R,C ≤ 100) indicating the key size. Then exactlyRrows follow,\r\neach containingCcharacters. Each character is either a hash mark\r\n(#) or a period (.). A hash mark represents one square field made\r\nof wood; a period is an empty field. The wooden fields are always connected,\r\ni.e. the whole key is made of one piece.\r\nMoreover, the key remains connected even if we cut off arbitrary number of rows\r\nfrom its top. There is always at least one\r\nnon-empty field in the top-most and bottom-most rows and the left-most and\r\nright-most columns.After the key description, there is a line containing two integersDandW(1 ≤ D ≤ 10000,1 ≤ W ≤ 1000). The numberWis the lock width,\r\nandDis its\r\ndepth. The nextDlines containWcharacters each. The character may be\r\neither a hash mark (representing the wood) or a period (the free space).OutputYour program should print one line of output for each test case. The line\r\nshould contain the statement\r\n\"The key falls to depthX.\". ReplaceXwith the maximum depth to which the key can be inserted by moving it down \r\nand sliding it to the left or right only. The depth is measured as the distance\r\nbetween the bottom side of the key and the top side of the lock. If it is\r\npossible to move the key through the whole lock and take it away at the bottom\r\nside, output the sentence \"The key can fall through.\".ExampleSample Input:\r\n4\r\n2 4\r\n#.##\r\n###.\r\n3 6\r\n#....#\r\n#....#\r\n#..###\r\n2 3\r\n##.\r\n.##\r\n2 7\r\n#.#.#.#\r\n.#.#.#.\r\n1 1\r\n#\r\n1 10\r\n###....###\r\n3 2\r\n##\r\n.#\r\n.#\r\n1 5\r\n#.#.#\r\n\r\nSample output:\r\nThe key falls to depth 2.\r\nThe key falls to depth 0.\r\nThe key can fall through.\r\nThe key falls to depth 2.Warning: large Input/Output data, be careful with certain languages",
  "sample_input": "Sample Input:\r\n4\r\n2 4\r\n#.##\r\n###.\r\n3 6\r\n#....#\r\n#....#\r\n#..###\r\n2 3\r\n##.\r\n.##\r\n2 7\r\n#.#.#.#\r\n.#.#.#.\r\n1 1\r\n#\r\n1 10\r\n###....###\r\n3 2\r\n##\r\n.#\r\n.#\r\n1 5\r\n#.#.#\r\n\r\nSample output:\r\nThe key falls to depth 2.\r\nThe key falls to depth 0.\r\nThe key can fall through.\r\nThe key falls to depth 2.",
  "sample_output": "Not found",
  "link": "https://www.spoj.com/problems/PROPKEY",
  "scraped_at": "2025-08-17 00:33:42"
}