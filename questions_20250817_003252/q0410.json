{
  "problem_code": "problems",
  "title": "Anti Hash",
  "tags": [],
  "text": "Given a baseBand a modulusM, the polynomial hash of a stringS, consisting of only lowercase letters(a-z)is defined as below:int Hash(string S, int B, int M){\r\n     long long H = 0;\r\n     for (int i = 0; i < S.length(); i++){\r\n           H = (H * B + S[i] - 'a' + 1) % M;\r\n     }\r\n     return H;\r\n}In other words, first the letters of the string are replaced by numbers (equivalent to their position,'a'gets mapped to1,'b'to2, ... and'z'to26). This is then considered to be a number in baseB(rightmost number is the least significant digit), and the value of this number inbase 10moduloMis called the polynomial hash of the string.Limak the bear loves to hack other contestants in Codeforces. After the recent educational round, he came to know that his friend Swistak used the polynomial hash function stated above to solve the hardest problem! And believe it or not, he was the only one to solve that problem! Limak is so angry, how can Swistak solve a problem which Limak himself couldn't solve? And worst of all, Swistak used hashing to solve that problem! Limak believes people who uses hashing have no real skill, gettingAcceptedjust implies getting lucky, nothing more!Later that night, Limak realized that he can hack the solution if he is able to solve the following problem efficiently. Limak felt triumphant, he will teach Swistak and that stupid hash function of his a lesson! But Limak is just a little bear, he is not very good at solving problems. Please help Limak solve the following problem so that he can hack Swistak's solution.Limak will give you a stringSof lengthN, consisting of only lowercase letters, a baseBand a modulusM. Your task is to find another stringT, satisfying all of the following constraints:Length ofTis exactlyNTconsists of only lowercase letters(a-z)TandSare two different stringsTandShave the same hash, i.e.Hash(S, B, M) = Hash(T, B, M)InputThe first line containsQ, denoting the number of test cases. Each test case consists of two lines. The first line of each case contains three integers,N, B, M. The next line contains the stringSof lengthN, consisting of only lowercase letters.Constraints1 ≤ Q ≤ 30105≤ N ≤ 106105≤ B < 231105≤ M < 231Si ∈ {a-z}B ≠ M and both B and M are prime numbersOutputFor each test case, output the stringTin a single line. It is guaranteed that such a string will always exist for the given constraints. If there are many solutions, you can output any of them.Sample Input1\r\n38 666666667 1000000009\r\nbbababbbbbbbaabaababaabbababbababababbSample OutputhisotomeseemslikeanotoriouscoincidenceNoteThe sample input contains a string of length 38 only for demonstration and clarity. There will be no such cases in the judge data, every case will strictly satisfy the constraints mentioned above.ChallengeYou might also enjoy:Anti Hash IIThe Revenge Of Anti Hash",
  "sample_input": "int Hash(string S, int B, int M){\r\n     long long H = 0;\r\n     for (int i = 0; i < S.length(); i++){\r\n           H = (H * B + S[i] - 'a' + 1) % M;\r\n     }\r\n     return H;\r\n}",
  "sample_output": "1\r\n38 666666667 1000000009\r\nbbababbbbbbbaabaababaabbababbababababb",
  "link": "https://www.spoj.com/problems/AHASH",
  "scraped_at": "2025-08-17 00:33:21"
}