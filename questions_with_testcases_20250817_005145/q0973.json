{
  "problem_code": "problems",
  "title": "Segfault",
  "tags": [],
  "text": "Little Petar and his fellow hacker Little Nikolaj enjoy playing the \"SIGSEGV\" game against one another in their free time, as all hackers do. In this game, two hackers compete for supremacy over a victim's RAM. To achieve this, they need to develop programs that will capture as many memory locations as possible for their own.The rules of the game are as follows:The RAM is represented by a matrix, RAM[][]; each field of this matrix may either befree, owned by Petar or Nikolaj, or owned by thevictim.Petar and Nikolaj's programs begin execution from a field of this matrix, and are able to perform only a single type of command: \"move to the field directly up, down, left or right from the current field, and attempt capturing it.\"If a program tries to capture a field that is not free and also not owned by its owner, it will receive asegfault(segmentation fault) signal andterminate immediately; however, the hacker owning it willretainall the memory that the program captured.Petar and Nikolaj may launchmanyprogramssimultaneously, should they have access to a multi-core computer. The programs may be launchedonlyat thestartof the game.Each hacker has gained an unfair advantage over the other:Nikolaj managed to make his capturing scheme faster, so if Petar and Nikolaj both attempt to capture the same (free) field at the same time, Nikolaj's program will capture it and Petar's program will terminate.Nikolaj owns a K-core computer, so he may launch K programs at the start of the game.Petar found out the entire initial state of the memory, as well as all of Nikolaj's programs. As Nikolaj doesn't know the initial state, he programmed his programs to be very simple: they begin at a given field and will always move in a single given direction (until encountering either the end of the matrix or a non-free field not owned by Nikolaj, after which it terminates).Nikolaj's programs will start their execution only after Petar's programs capture the initial field.Due to a virus that Nikolaj inserted in Petar's programs, all of them must start from the same field.Petar owns the latest Pintel Core i∞ processor that has infinitely many cores; as such, Petar may initially launch an arbitrary number of programs (however, they must all start from the same field, as mentioned before).Petar is interested in knowing how many fields of the RAM can he capture if he plays optimally.InputThe first line of the standard input contains two natural numbers N and M separated by a space; these represent the number of rows and columns of the RAM[][] matrix, respectively.The following N lines contain an M-character string each, representing the initial state of the memory (RAM[i][j] is represented by the j-th character in the i-th line):Character '.' represents a free field;Character '#' represents a field owned by the victim;Character 'S' represents the field from which all of Petar's programs must start.The following line contains a natural number K, the number of cores of Nikolaj's processor. Each of the following K lines contains the description of one of Nikolaj's programs, in the form X Y DIR, where X and Y are integers representing the program's starting field, and DIR is a character representing the program's only direction of movement ('U' - up, 'D' - down, 'L' - left, 'R' - right).OutputIn the first and only line of the standard output, print the number of memory locations that Petar may capture, assuming he plays optimally.ExampleInput:6 5#.S.#.............####......##22 1 R3 5 LOutput:18ExplanationPetar can achieve the optimal strategy with only launching a single program; this program should make its first two steps downwards, and the state of the RAM will change as follows (let 'P' represent fields owned by Petar, and 'N' represent the fields owned by Nikolaj):#.P.#      #.P.#      #.P.#\r\n.....      N.P..      NNP..\r\n.....  =>  ....N  =>  ..PNN\r\n...##  =>  ...##  =>  ...##\r\n##...      ##...      ##...\r\n...##      ...##      ...##Both of Nikolaj's programs will hence receive a segfault in the next step, leaving Petar free to capture all of the remaining fields of the matrix (18 in total).Constraints1 ≤ N, M ≤ 10001 ≤ K ≤ 5 × 1051 ≤ X ≤ N1 ≤ Y ≤ MRAM[X][Y] is not equal to '#'.",
  "sample_input": "Input:6 5#.S.#.............####......##22 1 R3 5 LOutput:18",
  "sample_output": "#.P.#      #.P.#      #.P.#\r\n.....      N.P..      NNP..\r\n.....  =>  ....N  =>  ..PNN\r\n...##  =>  ...##  =>  ...##\r\n##...      ##...      ##...\r\n...##      ...##      ...##",
  "link": "https://www.spoj.com/problems/SEGFAULT",
  "scraped_at": "2025-08-17 00:33:25",
  "test_cases": [
    {
      "input": "6 5#.S.#.............####......##22 1 R3 5 L",
      "expected_output": "18",
      "type": "sample_1",
      "description": "Original sample 1 from problem statement"
    },
    {
      "input": "9 5 1 9 3 5\n6 ao 9 xhe 5 jvpm",
      "expected_output": "To be computed",
      "type": "small_case_2",
      "description": "Generated small test case"
    },
    {
      "input": "8 3 6 6 10 2\n7 jmmpxwnhwydcypzhwupksmrx 3 jxmbp 7 j",
      "expected_output": "To be computed",
      "type": "small_case_3",
      "description": "Generated small test case"
    },
    {
      "input": "8 10 2 2 5 4\n1 izvmmhhc 2 rg 5 hyk",
      "expected_output": "To be computed",
      "type": "small_case_4",
      "description": "Generated small test case"
    },
    {
      "input": "96 4 12 15 88 44\n76 mjypuw 47 gd 62 ylznc",
      "expected_output": "To be computed",
      "type": "medium_case_5",
      "description": "Generated medium test case"
    },
    {
      "input": "18 29 36 54 88 24\n88 q 96 xiej 46 tvr",
      "expected_output": "To be computed",
      "type": "medium_case_6",
      "description": "Generated medium test case"
    },
    {
      "input": "49 65 32 76 9 12\n47 ilduxcyybsxbmjxuafznkryrcxmzdywb 20 jwm 68 r",
      "expected_output": "To be computed",
      "type": "medium_case_7",
      "description": "Generated medium test case"
    },
    {
      "input": "97 20 58 59 34 56\n14 vypprjmkao 42 x 71 skme",
      "expected_output": "To be computed",
      "type": "medium_case_8",
      "description": "Generated medium test case"
    },
    {
      "input": "88 93 71 16 18 97\n34 ppqabqbfkmdqayuwgangz 1 vdoq 91 dksi",
      "expected_output": "To be computed",
      "type": "medium_case_9",
      "description": "Generated medium test case"
    },
    {
      "input": "494 216 182 300 79 69\n344 hshusqppoeuldsdqu 347 qxmc 440 xnqy",
      "expected_output": "To be computed",
      "type": "large_case_10",
      "description": "Generated large test case"
    },
    {
      "input": "411 291 266 317 282 109\n317 pwatjv 329 urix 443 ted",
      "expected_output": "To be computed",
      "type": "large_case_11",
      "description": "Generated large test case"
    },
    {
      "input": "115 426 312 61 248 179\n143 pvtsoaei 142 fa 118 z",
      "expected_output": "To be computed",
      "type": "large_case_12",
      "description": "Generated large test case"
    },
    {
      "input": "354 500 379 363 409 329\n320 zccjilhdiizjiih 296 y 152 tj",
      "expected_output": "To be computed",
      "type": "large_case_13",
      "description": "Generated large test case"
    },
    {
      "input": "196 272 319 354 69 222\n116 ygrkvegvndrffqajtyxeeybxizjpkdklp 153 sx 149 p",
      "expected_output": "To be computed",
      "type": "large_case_14",
      "description": "Generated large test case"
    },
    {
      "input": "207 420 105 123 364 57\n179 zbmwifxdwjdk 466 asprp 262 wplzm",
      "expected_output": "To be computed",
      "type": "large_case_15",
      "description": "Generated large test case"
    },
    {
      "input": "413 272 84 145 353 421\n215 bypgr 372 uq 253 r",
      "expected_output": "To be computed",
      "type": "large_case_16",
      "description": "Generated large test case"
    },
    {
      "input": "1000 1000 1000 1000 1000 1000\n1000 ub 1000 uv 1000 akhm",
      "expected_output": "To be computed",
      "type": "max_case_17",
      "description": "Generated max test case"
    },
    {
      "input": "1000 1000 1000 1000 1000 1000\n1000 crfbhaaqsjdnxau 1000 mwrw 1000 l",
      "expected_output": "To be computed",
      "type": "max_case_18",
      "description": "Generated max test case"
    },
    {
      "input": "2 1 1000 1000 1000 1\n2 igibderbyyge 1000 q 1 lr",
      "expected_output": "To be computed",
      "type": "edge_case_19",
      "description": "Generated edge test case"
    },
    {
      "input": "1000 999 999 1 2 1000\n1000 booibmyflxyxq 1000 qduxo 999 ubgf",
      "expected_output": "To be computed",
      "type": "edge_case_20",
      "description": "Generated edge test case"
    }
  ],
  "test_cases_generated_at": "2025-08-17 00:51:48",
  "total_test_cases": 20
}